package integra

import (
	"errors"
	"testing"
)

func TestNewEISCPPacket(t *testing.T) {
	expected := []byte{
		0x49, 0x53, 0x43, 0x50,
		0x00, 0x00, 0x00, 0x10,
		0x00, 0x00, 0x00, 0x08,
		0x01, 0x00, 0x00, 0x00,

		0x21, 0x31, 0x50, 0x57,
		0x52, 0x30, 0x30, 0x0a,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00}
	result := newEISCPPacket()
	_ = result.init("PWR00")
	for i, b := range result {
		if b != expected[i] {
			t.Errorf("%v did not match expected %v at index %v", b, expected[i], i)
		}
	}

}

func TestNewEISCPPacketTooBig(t *testing.T) {
	expected := "Message 'OVER THE HILLS' too long"
	packet := newEISCPPacket()
	result := packet.init("OVER THE HILLS")
	if result == nil {
		t.Error("expected non-nil error")
	} else if result.Error() != expected {
		t.Errorf("expected error %v but got %v", expected, result)
	}
}

func TestEISCPPacketMessage(t *testing.T) {
	expected := "PWR01"
	packet := eISCPPacket{
		0x49, 0x53, 0x43, 0x50,
		0x00, 0x00, 0x00, 0x10,
		0x00, 0x00, 0x00, 0x08,
		0x01, 0x00, 0x00, 0x00,

		0x21, 0x31, 0x50, 0x57,
		0x52, 0x30, 0x31, 0x0a,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00}
	result := packet.message().String()
	if result != expected {
		t.Errorf("%v did not match %v", result, expected)
	}
}

func TestCheckEISPPacket(t *testing.T) {
	tests := []struct {
		input    eISCPPacket
		expected error
	}{
		{eISCPPacket{
			0x49, 0x53, 0x43, 0x50,
			0x00, 0x00, 0x00, 0x10,
			0x00, 0x00, 0x00, 0x08,
			0x01, 0x00, 0x00, 0x00,

			0x21, 0x31, 0x50, 0x57,
			0x52, 0x30, 0x31, 0x1a,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
		}, nil},
		{make(eISCPPacket, 32),
			errors.New("first 4 header bytes do not match ISCP")},
		{eISCPPacket{
			0x49, 0x53, 0x43, 0x51,
			0x00, 0x00, 0x00, 0x10,
			0x00, 0x00, 0x00, 0x08,
			0x01, 0x00, 0x00, 0x00,

			0x21, 0x31, 0x50, 0x57,
			0x52, 0x30, 0x31, 0x1a,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
		}, errors.New("first 4 header bytes do not match ISCP")},
		{eISCPPacket{
			0x49, 0x53, 0x43, 0x50,
			0x00, 0x00, 0x00, 0x10,
			0x00, 0x00, 0x00, 0x08,
			0x01, 0x00, 0x00, 0x00,

			0x20, 0x31, 0x50, 0x57,
			0x52, 0x30, 0x31, 0x1a,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
		}, errors.New("first 2 data bytes do not match !1")},
		{eISCPPacket{
			0x49, 0x53, 0x43, 0x50,
			0x00, 0x00, 0x00, 0x10,
			0x00, 0x00, 0x00, 0x08,
			0x01, 0x00, 0x00, 0x00,

			0xff, 0xff, 0x50, 0x57,
			0x52, 0x30, 0x31, 0x1a,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
		}, errors.New("first 2 data bytes do not match !1")},
		{eISCPPacket{
			0x49, 0x53, 0x43, 0x50,
			0x00, 0x00, 0x00, 0x11,
			0x00, 0x00, 0x00, 0x08,
			0x01, 0x00, 0x00, 0x00,

			0x21, 0x31, 0x50, 0x57,
			0x52, 0x30, 0x31, 0x1a,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
		}, errors.New("header size 0x11 is not expected size 0x10")},
		{eISCPPacket{
			0x49, 0x53, 0x43, 0x50,
			0x00, 0x00, 0x00, 0x10,
			0x00, 0x00, 0x00, 0x11,
			0x01, 0x00, 0x00, 0x00,

			0x21, 0x31, 0x50, 0x57,
			0x52, 0x30, 0x31, 0x1a,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
		}, errors.New("data size 0x11 greater than max size 0x10")},
		{eISCPPacket{
			0x49, 0x53, 0x43, 0x50,
			0x00, 0x00, 0x00, 0x10,
			0x00, 0x00, 0x00, 0x08,
			0x01, 0x00, 0x00, 0x00,

			0x21, 0x31, 0x50, 0x57,
			0x52, 0x30, 0x31, 0x0a,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
		}, errors.New("end of packet 0x0a did not match expected value 0x1a")},
	}
	for _, test := range tests {
		result := test.input.check(endOfPacketRx)
		if result == nil && test.expected == nil {
			// ok
		} else if result == nil || test.expected == nil {
			t.Errorf("'%v' did not match expected '%v'", result, test.expected)
		} else if result.Error() != test.expected.Error() {
			t.Errorf("'%v' did not match expected '%v'", result, test.expected)
		}
	}
}

func TestDebugString(t *testing.T) {
	packet := eISCPPacket{
		0x49, 0x53, 0x43, 0x50,
		0x00, 0x00, 0x00, 0x10,
		0x00, 0x00, 0x00, 0x08,
		0x01, 0x00, 0x00, 0x00,

		0x21, 0x31, 0x50, 0x57,
		0x52, 0x30, 0x31, 0x0a,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00}
	expected := `
0x49 0x53 0x43 0x50
0x00 0x00 0x00 0x10
0x00 0x00 0x00 0x08
0x01 0x00 0x00 0x00
0x21 0x31 0x50 0x57
0x52 0x30 0x31 0x0a
0x00 0x00 0x00 0x00
0x00 0x00 0x00 0x00
`
	if result := packet.debugString(); result != expected {
		t.Errorf("%v did not match %v", result, expected)
	}
}
